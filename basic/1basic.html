<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Basic</title>
    <style>
        body {
            font-size: 30px
        }

        a {
            font-size: 20px
        }
    </style>
</head>

<body>
    <!-- Польза отдельных файлов в том, что браузер загрузит скрипт отдельно и сможет хранить его в кеше. 
Если атрибут src установлен, содержимое тега script будет игнорироваться.
В одном теге <script> нельзя использовать одновременно атрибут src и код внутри -->
    <script>
        document.body.innerHTML = '';
        // debugger; // <-- отладчик остановится тут

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'alert, prompt, confirm' + '<br><br>'

        // alert, prompt, confirm

        // alert("Hello");
        // result = prompt(title, [default - Текст для отображения в окне]);  // -> text or undefined
        // let test = prompt("Test", ''); // <-- для IE
        // result = confirm(question); // true, если нажата OK

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Variables' + "<br><br>"

        // let и const ведут себя одинаково по отношению к лексическому окружению, области видимости.
        // Объявления переменных var обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной)
        // и имеют значение undefined до строки с присвоением значения
        // Для «var» не существует блочной области видимости
        // Если блок кода находится внутри функции, то var становится локальной переменной в этой функции
        // Если в блоке кода дважды объявить одну и ту же переменную let, будет ошибка
        // Используя var, можно переобъявлять переменную сколько угодно раз. Повторные var игнорируются,
        // а если дополнительно присвоить значение, то переменная примет новое значение

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Data types' + "<br><br>"

        // В JavaScript тип number не может безопасно работать с числами, большими, чем (253-1) (т. е. 9007199254740991) 
        // или меньшими, чем -(253-1) для отрицательных чисел.
        console.log(9007199254740991 + 1); // 9007199254740992
        console.log(9007199254740991 + 2); // 9007199254740992

        // символ "n" в конце означает, что это BigInt
        const bigInt = 1234567890123456789012345678901234567890n;

        console.log(-1 / 0); // -Infinity
        console.log(3e-5); // 0.00003
        console.log(0xFF); // 255 в шестнадцатиричной системе
        // let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
        // let b = 0o377; // восьмеричная форма записи числа 255

        var n = 0 / 0;
        console.log(isNaN(n)); // true

        console.log(isFinite(1)); // true
        console.log(isFinite(Infinity)); // false
        console.log(isFinite(NaN)); // false
        console.log(+"12test"); // NaN

        console.log(parseInt('12px')); // 12
        console.log(parseInt('FF', 16)); // 255
        console.log(parseFloat('12.3'))

        // точная проверка на число
        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }

        // Методы Number.isNaN и Number.isFinite – это более «строгие» версии функций isNaN и isFinite.

        // Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
        // Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
        // Значения 0 и -0 разные: Object.is(0, -0) === false
        // Во всех других случаях Object.is(a, b) идентичен a === b
        // такой трюк можно встретить только в старом коде, потому что в новом он просто не нужен: есть метод .includes

        var n = 1234567890;
        console.log(n.toString(36)); // kf12oi

        // Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, 
        // поскольку синтаксис JavaScript предполагает, что после первой точки начинается десятичная часть
        console.log(123456..toString(36)); // 2n9c
        // Также можно записать как (123456).toString(36).

        console.log(Math.floor(3.1));  // 3
        console.log(Math.ceil(3.1));   // 4
        console.log(Math.round(3.1));  // 3

        var n = 12.34;
        console.log(n.toFixed(1)); // "12.3"

        // problem:
        console.log(0.1 + 0.2 == 0.3); // false - // 0.30000000000000004
        // обойти проблему
        let sum = 0.1 + 0.2;
        console.log(sum.toFixed(2)); // 0.30 - string
        console.log(+sum.toFixed(2)); // 0.3 - number

        // Math.sqrt(x)
        // Math.log(x) // Возвращает натуральный (по основанию e) логарифм x
        // Math.pow(x, exp)
        // Math.abs(x)
        // Math.exp(x)  // Возвращает ex, где e – основание натуральных логарифмов.
        // Math.max(a, b, c...)
        // Math.random() // псевдослучайное число в интервале [0,1)

        var str = "My\n"; // 3 символа. Третий - перевод строки
        console.log(str.length); // 3
        console.log(str.charAt(0));
        console.log(str[0]);
        console.log(str.at(-2));   // y   
        console.log(str[-2]); // undefined
        str.toLocaleLowerCase();

        var str = "Widget with id";
        console.log(str.indexOf("id")); // 1, т.к. "id" найден, начиная с позиции 1
        console.log(str.indexOf("id", 2)) // 12, поиск начат с позиции 2

        var str = "stringify";
        console.log(str.substring(0, 1)); // "s", символы с позиции 0 по 1 не включая 1.
        str = str.substr(2, 4); // ring, со 2-й позиции 4 символа
        // slice(start [, end])


        console.log("testme".substring(-2)); // "testme", -2 становится 0

        console.log("testme".substring(4, -1)); // "test"
        // -1 становится 0 -> получили substring(4, 0)
        // 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"

        console.log("testme".slice(-2)); // "me", от 2 позиции с конца
        console.log("testme".slice(1, -1)); // "estm", от 1 позиции до первой с конца.

        console.log("Widget with id".includes("Widget")); // true
        console.log("Midget".includes("id", 3)); // false, поиск начат с позиции 3
        console.log("Widget".startsWith("Wid")); // true, "Wid" — начало "Widget"
        console.log("Widget".endsWith("get")); // true, "get" — окончание "Widget"

        console.log("z".codePointAt(0)); // 122
        console.log("Z".codePointAt(0)); // 90
        console.log(String.fromCodePoint(90)); // Z

        // Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:
        // Отрицательное число, если str меньше str2.
        // Положительное число, если str больше str2.
        // 0, если строки равны.

        // str.trim() — убирает пробелы в начале и конце строки.
        // str.repeat(n) — повторяет строку n раз.

        ////////
        console.log(5 + ""); // valueOf

        // wrapers
        // Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.
        // null/undefined не имеют методов

        // Конструкторы String/Number/Boolean предназначены только для внутреннего пользования, 
        // это тоже возможно по историческим причинам, но очень не рекомендуется. // new Number(0)

        // С другой стороны, использование функций String/Number/Boolean без оператора new – вполне разумно и полезно 
        // let num = Number("123"); // превращает строку в число        

        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Dates' + '<br><br>'


        // next output the same - Sat Nov 04 2023 00:32:11 GMT+0200 (Israel Standard Time)
        console.log(new Date);
        console.log(new Date + ""); // toString, бинарный плюс для даты toString, для остальных объектов valueOf
        console.log("" + new Date); // toString
        console.log(new Date()); // toString

        new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 января 2011, 00:00:00
        new Date(2011, 0, 1); // то же самое, часы/секунды по умолчанию равны 0

        console.log(new Date(2011, 0, 1, 2, 3, 4, 567)); // 1.01.2011, 02:03:04.567


        console.log(+new Date()); // valueOf: кол-во миллисекунд, прошедших с 01.01.1970  

        // 24 часа после 01.01.1970 GMT+0
        var Jan02_1970 = new Date(3600 * 24 * 1000);
        console.log(Jan02_1970);


        console.log("=================");


        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'typeof & Type Conversion' + "<br><br>"

        typeof undefined // "undefined"
        typeof 0 // "number"  // Number can be Nan, Infinity
        typeof 10n // "bigint"
        typeof true // "boolean"
        typeof "foo" // "string"
        typeof {} // "object"
        typeof Math // "object"
        typeof null // "object"  (1) Official bug. Should be null
        typeof function () { } // "function"  (2) Is not type. Just show
        typeof alert // "function" (2) Is not type. Just show
        typeof Symbol("id") // "symbol"


        // Преобразование типов
        let value = true; // boolean
        value = String(value); // теперь value это строка "true"
        console.log("6" / "2"); // 3, строки преобразуются в числа

        let apples = "2";
        let oranges = "3";
        console.log(+apples + +oranges); // 5, число, оба операнда предварительно преобразованы в числа
        // более длинный вариант
        // alert( Number(apples) + Number(oranges) ); // 5

        // операнды разных типов преобразуются оператором == к числу
        console.log(0 === false); // false, т.к. типы различны

        (+true); // 1  // На самом деле это то же самое, что и Number(...), только короче.
        (+"");   // 0

        let a = +"123"; // 123
        a = Number("123"); // 123, тот же эффект

        console.log(!!"0"); // true
        console.log(!!" "); // любые непустые строки, даже из пробелов - true!

        var access = parseInt("11000", 2); // получаем число из строки
        console.log(access); // 24, число с таким 2-ным представлением
        var access2 = access.toString(2); // обратно двоичную строку из числа
        console.log(access2); // 11000

        console.log(~~12.345); // 12
        console.log(12.345 ^ 0); // 12

        console.log(String(null) === "null"); // true

        // Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
        // При преобразовании в число null становится 0, а undefined становится NaN.
        // NaN – единственное в своем роде, которое не равно ничему, включая себя

        // для 32-разрядных целых чисел значение ~n равно -(n+1)
        // ~n == 0 только если n == -1
        // Соответственно, прохождение проверки if ( ~str.indexOf("…") ) означает, что результат indexOf отличен от -1, совпадение есть
        // Просто запомните: if (~str.indexOf(…)) означает «если найдено».

        let age = Number("Любая строка вместо числа"); // NaN, преобразование не удалось
        Number(null) // 0
        Number(true) // 1

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Operators' + "<br><br>"

        // Оператор нулевого слияния (??) - Nullish coalescing operator (??)
        // значение «определено», если оно не равняется ни null, ни undefined
        // a ?? b  -> если a определено, то a, если a не определено, то b
        // Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.

        let x = 1;
        let b = 0;
        switch (x) {
            case b + 1:  // if (x === b + 1)
            //break
            default:
            //break
        }
        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Обработка ошибок' + "<br><br>"

        try {
            lalala; // ошибка, переменная не определена!
        } catch (err) {
            console.log(err.name); // ReferenceError
            console.log(err.message); // lalala is not defined
            console.log(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)

            // Можем также просто вывести ошибку целиком
            // Ошибка приводится к строке вида "name: message"
            console.log(err); // ReferenceError: lalala is not defined
        }


        // Блок «catch» без переменной
        // Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил
        // Если нам не нужны детали ошибки, в catch можно её пропустить  catch { //  <-- без (err)


        // throw
        // let error = new Error(message);
        // let error = new SyntaxError(message);
        // let error = new ReferenceError(message);


        let myError = new SyntaxError("Ого, ошибка! o_O");
        console.log(myError.name); // SyntaxError
        console.log(myError.message); // Ого, ошибка! o_O

        try {
            throw new SyntaxError("Данные неполны: нет имени"); // (*)
        } catch (e) {
            console.log("Thrown Error: " + e.message); // JSON Error: Данные неполны: нет имени
        } finally {
            console.log('finally');
        }


        // проброс исключения, catch обрабатывает только SyntaxError
        try {
            // blabla(); // неожиданная ошибка
            throw new SyntaxError("Данные неполны: нет имени");
        } catch (e) {
            if (e.name == "SyntaxError") {
                console.log("Thrown Error: " + e.message); // JSON Error: Данные неполны: нет имени
            } else {
                throw e; // проброс (*)
            }
        }

        // Глобальный catch. Информация из данной секции не является частью языка JavaScript!!!.
        // в Node.js для этого есть process.on("uncaughtException"). 
        // А в браузере мы можем присвоить функцию специальному свойству window.onerror, которая будет вызвана в случае необработанной ошибки
        window.onerror = function (message, url, line, col, error) {
            console.log(`${message}\n В ${line}:${col} на ${url}`);
        };


        // Пользовательские ошибки, расширение Error
        class ValidationError extends Error {
            constructor(message) {
                super(message); // (1)
                this.name = "ValidationError"; // (2)
            }
        }

        class PropertyRequiredError extends ValidationError {
            constructor(property) {
                super("Нет свойства: " + property);
                this.name = "PropertyRequiredError";
                this.property = property;
            }
        }

        function readUser(json) {
            let user = JSON.parse(json);

            if (!user.age) {
                throw new ValidationError("Нет поля: age");
            }
            if (!user.name) {
                throw new PropertyRequiredError("Нет поля: name");
            }

            return user;
        }

        try {
            let user = readUser('{ "age": 25 }');
        } catch (err) {
            if (err instanceof ValidationError) {
                console.log("Некорректные данные: " + err.message); // Некорректные данные: Нет поля: name
            } else if (err instanceof PropertyRequiredError) {   
                console.log("JSON Ошибка Синтаксиса: " + err.message);
            } else if (err instanceof SyntaxError) {   // = else if (err.name == "SyntaxError")
                console.log("JSON Ошибка Синтаксиса: " + err.message);
            } else {
                throw err; // неизвестная ошибка, пробросить исключение (**)
            }
        }

        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'TODO: собственный «базовый» класс ошибки' + "<br><br>"
        document.body.innerHTML += 'TODO: Обёртывание исключений' + "<br><br>"

        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////


    </script>

    <br>
    <a href="../index.html">home</a>

</body>

</html>