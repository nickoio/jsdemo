<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Functions</title>
    <style>
        body {
            font-size: 30px
        }

        a {
            font-size: 20px
        }
    </style>
</head>

<body>

    <script>
        document.body.innerHTML = '';

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Function Declaration' + "<br><br>"

        // Function Declaration
        function showMessage(from, text) {
            if (text === undefined) {  // call as showMessage('myname')
                text = 'текст не передан';
            }
            // or
            text = text || 'текст не передан';
        }
        // функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода
        // Поэтому их можно вызвать до объявления

        // Function Expression
        var sayHi = function (person) {
            console.log("Привет, " + person);
        };

        // Named Function Expression
        var f = function sayHi(person) { /* тело функции */ };
        // Имя функционального выражения (sayHi) имеет особый смысл. Оно доступно только изнутри самой функции (f).
        // Кроме того, имя NFE нельзя перезаписать
        // example:
        var f = function factorial(n) {
            return n ? n * factorial(n - 1) : 1;
        };
        var g = f;  // скопировали ссылку на функцию-факториал в g
        f = null;
        console.log(g(5)); // 120, работает!


        // new Function
        var sum = new Function('a,b', ' return a+b; ');

        // Arrow function expressions
        let sum2 = (a, b) => a + b;

        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Argument by default' + "<br><br>"

        //   function showMessage(from, text = "текст не добавлен") {  // text значение по умолчанию
        //   alert( from + ": " + text );
        // }

        // function showMessage(from, text = anotherFunction()) {
        //   // anotherFunction() выполнится только если не передан text
        //   // результатом будет значение text
        // }

        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'Остаточные параметры и оператор расширения' + "<br><br>"


        function showName(firstName, lastName, ...titles) {
            console.log(firstName + ' ' + lastName); // Юлий Цезарь

            // Оставшиеся параметры пойдут в массив
            // titles = ["Консул", "Император"]
            console.log(titles[0]); // Консул
            console.log(titles[1]); // Император
            console.log(titles.length); // 2
        }
        showName("Юлий", "Цезарь", "Консул", "Император");


        // Переменная "arguments"
        function showName2() {
            console.log(arguments.length);
            console.log(arguments[0]);
            console.log(arguments[1]);

            // Объект arguments можно перебирать
            // for (let arg of arguments) alert(arg);
        }
        // Вывод: 2, Юлий, Цезарь
        showName2("Юлий", "Цезарь");
        // Вывод: 1, Илья, undefined (второго аргумента нет)
        showName2("Илья");


        // Мы узнали, как получить массив из списка параметров.
        // Но иногда нужно сделать в точности противоположное.
        // Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.
        let arr = [3, 5, 1];
        console.log(Math.max(...arr)); // 5 (оператор "раскрывает" массив в список аргументов)

        let arr1 = [1, -2, 3, 4];
        let arr2 = [8, 3, -8, 1];
        console.log(Math.max(1, ...arr1, 2, ...arr2, 25)); // 25


        let str = "Привет";
        console.log([...str]); // П,р,и,в,е,т





        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////

        document.body.innerHTML += 'IIFE' + "<br><br>"


            // В прошлом, поскольку существовал только var, а он не имел блочной области видимости, программисты придумали способ её эмулировать. 
            // Этот способ получил название «Immediately-invoked function expressions» (сокращенно IIFE).


            // Способы создания IIFE

            ; (function () {
                console.log("Круглые скобки вокруг функции");
            })();

        (function () {
            console.log("Круглые скобки вокруг всего выражения");
        }());

        !function () {
            console.log("Выражение начинается с логического оператора НЕ");
        }();

        +function () {
            console.log("Выражение начинается с унарного плюса");
        }();



        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////





        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////




        console.log("=================");

        ////////////////////////////////////////////////////////////////////////////////////

    </script>

    <br>
    <a href="../index.html">home</a>

</body>

</html>