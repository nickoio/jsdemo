<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MyTitle</title>
</head>
<body>

 <!--===================================================================-->
<!--if 2 or more "defer" -> order of script is the same -->
<p>Before</p>
<script src="basicUtils/async.js" async></script>
<script src="basicUtils/defer.js" defer></script>
<p>After</p>

<!-- Польза отдельных файлов в том, что браузер загрузит скрипт отдельно и сможет хранить его в кеше. 
Если атрибут src установлен, содержимое тега script будет игнорироваться.
В одном теге <script> нельзя использовать одновременно атрибут src и код внутри -->
 <script src="basic.js"></script>

<script>

// alert("Hello");
// result = prompt(title, [default - Текст для отображения в окне]);  // -> text or undefined
// let test = prompt("Test", ''); // <-- для IE
// result = confirm(question); // // true, если нажата OK


  typeof undefined // "undefined"
  typeof 0 // "number"  // Number can be Nan, Infinity
  typeof 10n // "bigint"
  typeof true // "boolean"
  typeof "foo" // "string"
  typeof {} // "object"
  typeof Math // "object"
  typeof null // "object"  (1) Official bug. Should be null
  typeof function(){} // "function"  (2) Is not type. Just show
  typeof alert // "function" (2) Is not type. Just show
  typeof Symbol("id") // "symbol"

  // let и const ведут себя одинаково по отношению к лексическому окружению, области видимости.

  // Объявления переменных var обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной)
  // и имеют значение undefined до строки с присвоением значения
  // Для «var» не существует блочной области видимости
  // Если блок кода находится внутри функции, то var становится локальной переменной в этой функции
  // Если в блоке кода дважды объявить одну и ту же переменную let, будет ошибка
  // Используя var, можно переобъявлять переменную сколько угодно раз. Повторные var игнорируются,
  // а если дополнительно присвоить значение, то переменная примет новое значение


  // В JavaScript тип number не может безопасно работать с числами, большими, чем (253-1) (т. е. 9007199254740991) 
  // или меньшими, чем -(253-1) для отрицательных чисел.
  console.log(9007199254740991 + 1); // 9007199254740992
  console.log(9007199254740991 + 2); // 9007199254740992

  // символ "n" в конце означает, что это BigInt
  const bigInt = 1234567890123456789012345678901234567890n;


  // Преобразование типов

  let value = true;
  console.log(typeof value); // boolean

  value = String(value); // теперь value это строка "true"
  console.log(typeof value); // string

  console.log( "6" / "2" ); // 3, строки преобразуются в числа

  var apples = "2";
  var oranges = "3";

  console.log( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа
  // более длинный вариант
  // alert( Number(apples) + Number(oranges) ); // 5

  // операнды разных типов преобразуются оператором == к числу
  console.log( 0 === false ); // false, т.к. типы различны

  ( +true ); // 1  // На самом деле это то же самое, что и Number(...), только короче.
  ( +"" );   // 0

  var a = +"123"; // 123
  var a = Number("123"); // 123, тот же эффект

  let age = Number("Любая строка вместо числа"); // NaN, преобразование не удалось
  Number(null) // 0
  Number(true) // 1

  console.log( !!"0" ); // true
  console.log( !!" " ); // любые непустые строки, даже из пробелов - true!

  var access = parseInt("11000", 2); // получаем число из строки
  console.log( access ); // 24, число с таким 2-ным представлением
  var access2 = access.toString(2); // обратно двоичную строку из числа
  console.log( access2 ); // 11000

  console.log( ~~12.345 ); // 12
  console.log( 12.345 ^ 0 ); // 12

  console.log( String(null) === "null" ); // true

  // Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
  // При преобразовании в число null становится 0, а undefined становится NaN.
  // NaN – единственное в своем роде, которое не равно ничему, включая себя

  // ~n == 0 только если n == -1

  // Оператор нулевого слияния (??)
  // значение «определено», если оно не равняется ни null, ни undefined
  // a ?? b  -> если a определено, то a, если a не определено, то b
  // Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.

  var x = 1;
  switch(x) {
    case 1:  // if (x === 1)
    //break
    default:
    //break
  }
// Function Declaration
  function showMessage(from, text) {
    if (text === undefined) {
      text = 'текст не передан';
    }
// or
    text = text || 'текст не передан';
  }

  // Function Expression
  var sayHi = function(person) {
    console.log( "Привет, " + person );
  };
  // функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода
  // Поэтому их можно вызвать до объявления

  // Named Function Expression
  var f = function sayHi(person) { /* тело функции */ };
  // Имя функционального выражения (sayHi) имеет особый смысл. Оно доступно только изнутри самой функции (f).
    // Кроме того, имя NFE нельзя перезаписать
  // example:
  var f = function factorial(n) {
    return n ? n*factorial(n-1) : 1;
  };
  var g = f;  // скопировали ссылку на функцию-факториал в g
  f = null;
  console.log( g(5) ); // 120, работает!

  // new Function
  var sum = new Function('a,b', ' return a+b; ');


 // debugger; // <-- отладчик остановится тут

  // console.log("значение", i);  // from browser F12

  console.log( -1 / 0 ); // -Infinity
  console.log( 3e-5 ); // 0.00003
  console.log( 0xFF ); // 255 в шестнадцатиричной системе

  var n = 0 / 0;
  console.log( isNaN(n) ); // true

  console.log( isFinite(1) ); // true
  console.log( isFinite(Infinity) ); // false
  console.log( isFinite(NaN) ); // false
  console.log( +"12test" ); // NaN

  console.log( parseInt('12px') ); // 12
  console.log( parseInt('FF', 16) ); // 255
  console.log( parseFloat('12.3') )

  // точная проверка на число
  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  var n = 1234567890;
  console.log( n.toString(36) ); // kf12oi

  console.log( Math.floor(3.1) );  // 3
  console.log( Math.ceil(3.1) );   // 4
  console.log( Math.round(3.1) );  // 3

  var n = 12.34;
  console.log( n.toFixed(1) ); // "12.3"

  // Math.sqrt(x)
  // Math.log(x) // Возвращает натуральный (по основанию e) логарифм x
  // Math.pow(x, exp)
  // Math.abs(x)
  // Math.exp(x)  // Возвращает ex, где e – основание натуральных логарифмов.
  // Math.max(a, b, c...)
  // Math.random() // псевдослучайное число в интервале [0,1)

  var str = "My\n"; // 3 символа. Третий - перевод строки
  console.log( str.length ); // 3
  console.log( str.charAt(0) );
  console.log( str[0] );
  str.toLocaleLowerCase();

  var str = "Widget with id";
  console.log( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
  console.log(str.indexOf("id", 2)) // 12, поиск начат с позиции 2

  var str = "stringify";
  console.log(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.
  str = str.substr(2,4); // ring, со 2-й позиции 4 символа
  // slice(start [, end])


  console.log( "testme".substring(-2) ); // "testme", -2 становится 0

  console.log( "testme".substring(4, -1) ); // "test"
  // -1 становится 0 -> получили substring(4, 0)
  // 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"

  console.log( "testme".slice(-2) ); // "me", от 2 позиции с конца
  console.log( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.


</script>

</body>
</html>